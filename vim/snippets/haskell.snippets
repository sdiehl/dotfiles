snippet new
	newtype ${1:name} a  $1 { un$1 :: ${2} a }
	  deriving (${3:Monad}, $4)

snippet mod
	module ${1} (
	  ${2}
	) where

snippet if
	if ${1}
	then ${2}
	else ${3}

snippet iq
	import qualified ${1:Data.Text} as ${2:T}

snippet m
	${1} = do ${2}
	         ${3}

snippet cl
	class ${1:Name} where
	  ${2}

snippet in
	instance ${1:Class} ${2:Type} where
	  ${3}

snippet rec
	data ${1:Type} = $1
			{ ${3:field} :: ${4:Type}
			, ${5}
			} deriving (${6:Classes})

snippet ff
	foreign import ccall safe "${1}" ${2}
	    :: ${3}

snippet pragma 
	{-# LANGUAGE ${1} #-}

snippet case
	case ${1} of
	     ${2} -> ${3}
	     ${4} -> ${5}

snippet let
	let ${1} = ${2} in
	${3}

snippet where
	where
	  ${1:fn} = ${2:undefined}

snippet if
	if ${1:condition}
	   then ${2:expression}
	   else ${3:expression}

snippet \
	\ ${1:pattern} -> ${2:expression}

snippet bar
	-------------------------------------------------------------------------------
	-- ${1}
	-------------------------------------------------------------------------------

snippet cat
	instance Category ${1} where
		id = ${2}
		(.) = ${3}

snippet fun
	instance Functor ${1} where
		fmap = ${2}

snippet monad
	instance Monad ${1} where
		${2} >>= f = ${3}
		return = ${4}

snippet usual
	import Data.Maybe
	import Data.Functor
	import Data.Foldable
	import Data.Traversable
	import Control.Monad
	import Control.Applicative

snippet containers
	import qualified Data.HashMap.Lazy as HashMap
	import qualified Data.HashSet      as HashSet
	import qualified Data.IntMap       as IntMap
	import qualified Data.IntSet       as IntSet
	import qualified Data.IxSet        as IxSet
	import qualified Data.Map          as Map
	import qualified Data.Sequence     as Seq
	import qualified Data.Set          as Set

snippet gadt 
	{-# LANGUAGE GADTs #-}

snippet rank
	{-# LANGUAGE RankNTypes #-}

snippet scope
	{-# LANGUAGE ScopedTypeVariables #-}

snippet ffi
	{-# LANGUAGE ForeignFunctionInterface #-}

snippet flex
	{-# LANGUAGE FlexibleInstances #-}
	{-# LANGUAGE FlexibleContexts #-}
	{-# LANGUAGE TypeSynonymInstances #-}

snippet syn
	{-# LANGUAGE TypeSynonymInstances #-}

snippet mparam
	{-# LANGUAGE MultiParamTypeClasses #-}

snippet bang
	{-# LANGUAGE BangPatterns #-}

snippet gnew
	{-# LANGUAGE GeneralizedNewtypeDeriving #-}

snippet mono
	{-# LANGUAGE NoMonomorphismRestriction #-}

snippet stand
	{-# LANGUAGE StandaloneDeriving #-}

snippet derive
	{-# LANGUAGE DeriveDataTypeable #-}
	{-# LANGUAGE DeriveGeneric #-}
	{-# LANGUAGE DeriveFunctor #-}
	{-# LANGUAGE DeriveTraversable #-}
	{-# LANGUAGE DeriveFoldable #-}

snippet type
	{-# LANGUAGE TypeFamilies #-}
	{-# LANGUAGE DataKinds #-}
	{-# LANGUAGE GADTs #-}
	{-# LANGUAGE FlexibleInstances #-}
	{-# LANGUAGE FlexibleContexts #-}
	{-# LANGUAGE KindSignatures #-}

snippet crazy
	{-# LANGUAGE GADTs #-}
	{-# LANGUAGE DataKinds #-}
	{-# LANGUAGE RankNTypes #-}
	{-# LANGUAGE TypeFamilies #-}
	{-# LANGUAGE TypeOperators #-}
	{-# LANGUAGE KindSignatures #-}
	{-# LANGUAGE FlexibleInstances #-}
	{-# LANGUAGE FlexibleContexts #-}
	{-# LANGUAGE MultiParamTypeClasses #-}
	{-# LANGUAGE UndecidableInstances #-}
	{-# LANGUAGE ImpredicativeTypes #-}
	{-# LANGUAGE ExistentialQuantification #-}

snippet main
	main = return ()

snippet nowarn
	{-# OPTIONS_GHC -fno-warn-name-shadowing  #-}
	{-# OPTIONS_GHC -fno-warn-type-defaults   #-}

snippet box
	--------------------------------------------------------------------
	-- |
	-- Module    :   
	-- Copyright :  (c) Stephen Diehl 2013
	-- License   :  MIT
	-- Maintainer:  stephen.m.diehl@gmail.com
	-- Stability :  experimental
	-- Portability: non-portable
	--
	--------------------------------------------------------------------

snippet dd
	deriving (Eq, Ord, Show, Typeable, Data, Generic)

snippet in
	{-# INLINE ${1} #-}

snippet inl
	{-# INLINEABLE ${1} #-}

snippet ub
	{-# UNBOX #-}

snippet un
	undefined
