:set -XPackageImports

import Control.Applicative
import Control.Arrow ((***), (&&&), (+++), (|||), left, right, first, second)
import Control.Category
import Control.Exception
import Control.Lens
import Control.Monad hiding ( forM , forM_ , mapM , mapM_ , msum , sequence , sequence_ )
import Control.Monad.Trans
import Data.Bool
import Data.Either
import Data.Foldable
import Data.Function hiding ((.), id)
import Data.List hiding ( all , and , any , concat , concatMap , elem , filter , find , foldl , foldl' , foldl1 , foldr , foldr1 , mapAccumL , mapAccumR , maximum , maximumBy , minimum , minimumBy , notElem , or , product , sum )

import Data.Maybe
import Data.Monoid
import Data.String
import Data.Traversable
import Data.Tuple

import Data.Eq
import Data.Ord

import Data.Int
import GHC.Real

import GHC.TypeLits

import Filesystem.Path hiding ( (<.>) , concat , empty , null , stripPrefix )
import System.IO hiding ( FilePath )
import Text.Show
import Text.Show.Pretty (ppShow)

import qualified Prelude
import Prelude ( (+), (-), (*), (/), mod , seq, ($!) , undefined, error, fromIntegral )

import qualified "mtl" Control.Monad.State as State
import qualified "mtl" Control.Monad.Reader as Reader
import qualified "mtl" Control.Monad.Error as Error

:set prompt "Î»: "

:def hlint const . return $ ":! hlint \"src\""
:def hoogle \s -> return $ ":! hoogle --count=15 \"" ++ s ++ "\""
:def pl \s -> return $ ":! pointfree \"" ++ s ++ "\""

:set -fwarn-incomplete-uni-patterns 

let pprint x = putStrLn $ ppShow x

let if' p x y = if p then x else y
let filter p = foldMap (\a -> if p a then pure a else mempty)
