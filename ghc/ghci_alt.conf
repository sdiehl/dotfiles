:set -XPackageImports

import Control.Applicative
import Control.Arrow (first, second)
-- import Control.Category
import Control.Exception
import Control.Lens
import Control.Monad hiding ( forM , forM_ , mapM , mapM_ , msum , sequence , sequence_ )
import Control.Monad.Trans
import Data.Bool
import Data.Either
import Data.Foldable
import Data.Function
import Data.List hiding ( all , and , any , concat , concatMap , elem , filter , find , foldl , foldl' , foldl1 , foldr , foldr1 , mapAccumL , mapAccumR , maximum , maximumBy , minimum , minimumBy , notElem , or , product , sum )

import Data.Maybe
import Data.Monoid
import Data.String
import Data.Traversable
import Data.Tuple

import Data.Eq
import Data.Ord

import Data.Int
import GHC.Real

import GHC.TypeLits

import Filesystem.Path hiding ( (<.>) , concat , empty , null , stripPrefix )
import System.IO hiding ( FilePath )
import Text.Show
import Text.Show.Pretty (ppShow)

import qualified Prelude
import Prelude ( (+), (-), (*), (/), mod , seq, ($!) , undefined, error, fromIntegral )

import qualified "mtl" Control.Monad.State as State
import qualified "mtl" Control.Monad.Reader as Reader
import qualified "mtl" Control.Monad.Except as Except

let pprint x = putStrLn $ ppShow x

let if' p x y = if p then x else y
let filter p = foldMap (\a -> if p a then pure a else mempty)
